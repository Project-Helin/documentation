\newpage
\section{Flugrouten}
Die zentrale Aufgabe des Projektes ist es Drohnen zu verwalten, die sich in einem geografischen Gebiet autonom und sicher bewegen können. 
Dieses Gebiet, beispielsweise die HSR (siehe Abb. \ref{fig:campus-hsr}) kann Hindernisse wie Gebäude oder Bäume enthalten, welche um- oder überflogen werden müssen. \\

\begin{figure}[H]
	\includegraphics[width=1.0\textwidth]{images/routing/topology_example.png}
	\caption{Topologische Ansicht des Campus HSR}
	\label{fig:campus-hsr}
\end{figure}

\subsection{Das Zonen Model}
Um Kollisionen mit statischen Objekten zu vermeiden und sichere Flugwege zu erhalten, wurde ein Zonen Model eingeführt. Dieses ermöglicht dem Anbieter zu definieren, wo geflogen werden kann und wie hoch dort geflogen werden muss. Die Abbildung \ref{fig:demo-project} zeigt die Benutzeroberfläche für die Zonendefinition anhand des HSR-Campus.

\begin{figure}[H]
	\includegraphics[width=1.0\textwidth]{images/routing/simpleProject_example.png}
	\caption{Einfaches Demo Projekt an der HSR}
	\label{fig:demo-project}
\end{figure}
Jedes Polygon bildet eine Zone ab. Jede Zone enthält eine Flughöhe sowie einen Typ:
\begin{itemize}
	\item{\textbf{Order Zone:} Zone in welchem die Produkte des Projekts bestellt werden können. (\textit{hell blauer Rahmen})}
	\item{\textbf{Loading Zone:} Zone in welcher die Drohne beladen wird. (\textit{orange})}
	\item{\textbf{Delivery Zone:} Zone in der geliefert und geflogen werden darf. (\textit{grün})}
	\item{\textbf{Flight Zone:} Zone in der nur geflogen aber nicht geliefert werden darf. (\textit{blau})}
\end{itemize}

\subsection{Von der Zone zum Graph}
Normalerweise wird eine Routenberechnung mit Hilfe eines Graphen durchgeführt, der durch die möglichen Wege (z.B. Strassen) definiert ist. Da die Zonen aber eine Fläche bilden, musste diese zuerst in einen Graphen umgewandelt werden. \\

Folgende Lösungsmöglichkeiten wurden evaluiert:

\subsubsection{Erstes Konzept: Direkte Route}
Dieses Konzept umfasste den Ansatz den Start und den Endpunkt direkt zu verbinden, und bei einem verlassen des Polygons dem Rand zu folgen (siehe Abb.\ref{fig:first-concet-routing}).

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{images/routing/firstSolution.png}
	\caption{Erstes Konzept}
	\label{fig:first-concet-routing}
\end{figure}
Es wurde ausserdem ein Rand (\textit{Rot}) hinzugefügt.Diese Massnahme wurde getroffen, um allfällige GPS Ungenauigkeiten zu berücksichtigen.\\

Der Nachteil dieser Lösung zeigt sich bei grösseren Polygonen, wo unnötigerweise dem Rand entlang geflogen wird, obwohl ein Flug durch die Mitte viel sicherer wäre.
\newpage
\subsubsection{Zweites Konzept: Visibility Graph}
Das nächste Konzept orientiert sich an einem 'Visibility Graphen'. 
\cite[p.1]{IEEEPaper} 

\blockquote{Using visibility graphs for determining the shortest path is very practical and intuitive. The visibility graph of a set of nonintersecting polygonal obstacles in the plane is an undirected graph whose vertices are the vertices of the obstacles and whose edges are pairs of vertices such that the open line segment between each two vertices does not intersect any of the obstacles.}
In unserem Fall haben wir den Gedanken umgedreht. Wir haben den Graphen in einem Polygon mit potentiellen Löchern berechnet. Diese Löcher stellen Enklaven für Bäume oder Gebäude dar. Das Konzept ist aber das gleiche, angewendet auf unser Beispiel Polygon ergibt sich folgende Abstraktion:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{images/routing/visibilityGraph.png}
	\caption{Visibility Graph in einer Flugzone}
	\label{fig:visibility-graph}
\end{figure}
Wie in der Grafik \ref{fig:visibility-graph} gezeigt wird, verlaufen deutlich weniger Flugrouten entlang der Kante des Polygons. \\
Dies ist eine deutliche Verbesserung gegenüber dem ersten Konzept. Der Nachteil ist, dass die untere Ecke des L-förmigen Polygons sicher angeflogen wird, da es die vermeintlich kürzeste Route in einem nächsten Schritt darstellen würde. Aus diesem Grund haben wir uns gegen den Einsatz dieses Konzepts entschieden.\\

\subsubsection{Drittes Konzept: Straight Skeleton}
Die Abbildung \ref{fig:skeleton-in-polygon} illustriert die Lösung mithilfe eines Skeletons. Dieses Konzept kann nachvollzogen werden, indem man sich das Polygon 3-dimensional vorstellt und dann  von der Mitte aus, parallel zu den Kanten schneidet. Der entstandene Grat ist hier als Linie sichtbar und wird als Skeleton bezeichnet.

Diese Lösung scheint ideal, da sie einen Flug in der Mitte bevorzugt und nur bei wechseln in eine andere Flugzone an den Rand fliegt.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{images/routing/skeleton.png}
	\caption{Skeleton in Polygon}
	\label{fig:skeleton-in-polygon}
\end{figure}

\subsection{Routing Algorithmus}
Nach der Herleitung des Graphen aus der Polygonstruktur, musste nun der passende Algorithmus gefunden werden um eine Lösung von A nach B zu finden. Es kamen 4 standard Algorithmen in Frage, wobei ein Algorithmus sich als besonders geeignet herausstellte.
\begin{itemize}
	\item{\textbf{BFS:} (\textit{Breadth-first search}) Die Breitensuche durchsucht einen Baum in der Breite. Sie bringt garantiert eine Lösung, wenn eine Lösung vorhanden ist und kann problemlos mit Zyklen im Graph umgehen. Bei der Lösung handelt es sich aber nicht um de 'optimale Lösung' (kürzester Pfad). Die Lösung liefert den Pfad mit den wenigsten Knoten. \cite{AiClass}}
	\item{\textbf{DFS:} (\textit{Depth-first search}) Die Tiefensuche fängt an einem Knoten an und arbeitet sich dann in die Tiefe. Das Problem ist, dass sie sehr anfällig auf Zyklen ist und ohne weitere Hilfsmittel (loop detection oder pruning) nicht terminieren kann. Aus diesen Gründen ist diese Lösung nicht die Beste für unser Problem. \cite{AiClass}}
	\item{\textbf{A-Star:} Der A-Star Algorithmus arbeitet mit einer Heuristik und funktioniert effizienter wie die zwei bereits genannten Algorithmen. In unserem Fall war der A-Star Algorithmus zwar eine interessante Option, da wir uns am Anfang nicht auf die 'optimale Lösung' gestürzt haben, sondern eine 'garantierte Lösung' wollten, war die Heuristik und der damit verbunden Aufwand, ein Kriterium dagegen. \cite{AiClass}}
	\item{\textbf{Dijkstra:} Der Dijkstra-Algorithmus ist ebenfalls ein klassischer Graphpropagierungsalgorithmus. Der Vorteil an ihm ist, dass er grundsätzlich ohne Heuristik auskommt und robust mit Zyklen umgehen kann. Als Metrik kann in unserem Fall einfach eine Konstante genommen werden, so optimiert er auf die kleinste Anzahl Knotentraversierungen im Lösungspfad.}
\end{itemize}
Nach genauerem Betrachten der Algorithmen haben wir uns für den Dijkstra Algorithmus entschieden. Er liefert ohne Metrik eine ähnliche Lösung wie die BFS-Suche. Der Vorteil ist, dass der Umgang mit einer Metrik bereits konzipiert ist, was ihn deutlich von der klassischen BFS-Suche unterscheidet.
In einer ersten Version haben wir auf die Längen-Metrik verzichtet, das Ziel war eine Lösung zu finden ohne zu Garantieren, dass es sich hierbei um die Beste handelt.
\subsection{Höhenhandling}
Bis an hin wurde die Höhe der einzelnen Polygone ausser acht gelassen, denn so konnten sämtlichen Polygone der drei Zonentypen zusammengefasst werden. Somit konnte mit einem Polygon, wie in der Grafik \ref{fig:skeleton-in-polygon} dargestellt, die Route berechnet werden.

Das Höhenhandling bildet nun den abschliessenden Schritt für die Routen-Berechnung und benötigt wieder Informationen der einzelnen Polygone, da die Höhe pro Zone individuell definiert werden kann.
Nachdem nun die Route innerhalb des Graphen berechnet wurden, muss für jeden Knotenpunkt die Höhe definiert werden. Dies geschieht in zwei Schritten:
\begin{itemize}
	\item{\textbf{Bestimmen der Zugehörigkeit des Knotens:} In einem ersten Schritt werden die Zonen nach Höhe absteigend sortiert. Im Anschluss werden bei einer Überlagerung von zwei Zonen die Differenzen der Polygone entfernt, somit können die höherliegenden Polygone die Tieferliegenden abdecken. Dieses Abdecken, garantiert später, dass die Punkte nur einmal zugeordnet werden und somit bei einer Überlagerung von zwei Zonen mit unterschiedlichen Höhen die Route nicht durch einen Tal vom höher- und tiefergelegenen Polygon führt.}
	\item{\textbf{Setzten der Höhe:} Es wird über alle Punkte iteriert, und die Höhe entsprechend dem Polygon indem es sich befindet gesetzt. Da die Überschneidungen nach Höhe im ersten Teil bereits vollzogen wurde, ist das Resultat eindeutig.}
\end{itemize}
\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\textwidth]{images/routing/height_example.png}
	\caption{Beispiel der Höhe am Übergang zweier Polygone}
	\label{fig:polygon-border-example}
\end{figure}
Wie gemäss der Abbildung \ref{fig:polygon-border-example} ersichtlich ist, ist trotz des langen geraden Pfades zwischen den zwei Zonen ein Punkt eingefügt. Im Grunde sind es zwei Punkte, die für den Wechsel der Flughöhe verantwortlich sind.
\newpage
\subsection{Wahl der Rückroute}
Das Bilden der Rückroute erfolgt in einem sehr einfachen verfahren. Bei der aktuellen Lösung werden Start und Endpunkt mit der dazugehörigen Aktion versehen. Im Falle des Endpunktes ist es in unserem Fall der Abwurf.
\\
Nun kann dieser Pfad genommen, umgedreht und angehängt werden, wobei der letzte Punkt entfernt wird. So ist garantiert, dass die Drohne den gleichen Rückweg wie hinweg verwendet um die Mission zu erfüllen. Diese Liste wird nun an den Autopiloten übergeben.
