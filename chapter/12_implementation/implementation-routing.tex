\newpage
\section{Flugrouten Planung}
Die topologische Überlegung spielt in der Umsetzung eine zentrale Rolle.
Die zentrale Aufgabe des Projektes ist es Drohnen zu verwalten, welche sich in einem geografischen Gebiet bewegen. 
Dieses Gebiet kann Hindernisse wie Gebäude oder Bäume beinhalten, welche möglichst sicher umflogen werden müssen. 
Statische Objekte mit unterschiedlicher Höhe können einfach umflogen oder überflogen werden, sofern die Drohne 'weiss' wie diese flugtechnisch zu vermeiden sind. \\
\begin{figure}[H]
	\includegraphics[width=1.0\textwidth]{images/routing/topology_example.png}
	\caption{Topologische Ansicht des Campus HSR}
	\label{fig:campus-hsr}
\end{figure}
Am Beispiel der HSR ist unschwer zu erkennen, wie Gebäude in der Landschaft unterschiedliche Höhen haben. Diese Höhenunterschiede sollte wenn möglich gut in einem Model abgebildet werden können. \\
Aus diesen Überlegungen entstand das Zonen Model.

\subsection{Das Zonen Model}
Betrachten wir nun ein einfaches Projekt am Campus der HSR, so könnte dies wie folgt aussehen. 
\begin{figure}[H]
	\includegraphics[width=1.0\textwidth]{images/routing/simpleProject_example.png}
	\caption{Einfaches Demo Projekt an der HSR}
	\label{fig:demo-project}
\end{figure}
Jedes Polygon bildet eine Zone ab. Diese Zonen können unterschiedliche Höhen, aber auch Eigenschaften aufweisen. Die Höhe gewährleistet die minimale Flughöhe in einer Zone. Weiter sind die Zone in vier verschiedenen Typen aufgeteilt: 
\begin{itemize}
	\item{\textbf{OrderZone:} Bereich aus welchem Produkte bestellt werden können. (\textit{hell blauer Rahmen})}
	\item{\textbf{LoadingZone:} Zone in welcher die Drohne beladen werden kann. (\textit{orange})}
	\item{\textbf{DeliveryZone:} Diese Zone definiert das Gebiet über welchem das Produkt abgeworfen werden kann. (\textit{grün})}
	\item{\textbf{FlightZone:} Die Flugzone verbindet die Ladezone mit der Abwurfzone. Weiter garantiert sie, dass die angegebene Flughöhe gewährleistet wird. (\textit{blau})}
\end{itemize}

\subsection{Routing-Algorithmus}
Das Zonenmodel lässt es einfach zu, dass Flugkorridore sehr intuitiv gebildet werden können. Leider eignen sich Polygone weniger gut für eine Navigation oder eine Routenberechnung. Die Routenberechnung im klassischen Sinne entsteht auf einem Graphen. Anhand des Graphs wird mit Start und Endpunkt eine Lösung berechnet und diese stellt dann die Route dar. Da dieses Konzept das Naheliegendste ist, sollten die Polygone auf einen Graph reduziert werden.

\subsection{Reduktion vom Polygon zum Graph}
Für das Routing sind nur die drei Zonen, LoadingZone, DeliveryZone und FlightZone von entscheidender Bedeutung. Diese Zonen können von den Drohen überflogen werden, die OrderZone hingegen dient ausschliesslich dazu, den bestellbaren Bereich einzuschränken. Beispielsweise kann so garantiert werden, dass der Kunde nicht Produkte aus der Stadt Zürich bestellen kann, welche von der HSR aus beliefert werden.
\\
Um die Problemstellung etwas besser zu verstehen, werden im folgenden drei möglichen Konzepte anhand eines Polygons demonstriert:
\subsubsection{Erste Konzept: Direkte Route}
Dieses Konzept umfasste den Ansatz den Start und den Endpunkt direkt zu verbinden, und bei einem verlassen des Polygons dem Rand nach zufliegen. Diese Lösung an einem Beispiel sah folgendermassen aus.
\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{images/routing/firstSolution.png}
	\caption{Erstes Konzept}
	\label{fig:first-concet-routing}
\end{figure}
Aus Sicherheitsgründen wurde ein zusätzlicher Rand (\textit{Rot}) berechnet. Das ursprüngliche Polygon wurde um 5 Meter geschrumpft um nicht zu nah an den realen Rand des Polygons zu fliegen (\textit{Blau}). Diese Massnahme wurde getroffen, um allfällige GPS Ungenauigkeit zu berücksichtigen. Die Drohne hat somit auch einen Sicherheitsabstand bei Flugfehler.
\\
So einfach dieses Konzept auch war, leider brachte es einige schwächen mit sich. Bei zu engen Korridoren war die Frage offen, wie der Rand definiert ist. Ausserdem kann im Extremfall die kürzeste und die berechnete Route weit voneinander abweichen.
\newpage
\subsubsection{Zweites Konzept: Visibility Graph}
Das nächste Konzept konzentrierte sich auf den 'Visibility Graphen'. 
\cite[p.1]{IEEEPaper} 
\blockquote{Using visibility graphs for determining the shortest path is very practical and intuitive. The visibility graph of a set of nonintersecting polygonal obstacles in the plane is an undirected graph whose vertices are the vertices of the obstacles and whose edges are pairs of vertices such that the open line segment between each two vertices does not intersect any of the obstacles.}
In unserem Fall haben wir den Gedanken umgedreht. Wir haben den Graphen in einem Polygon mit potentiellen Löchern berechnet. Diese Löcher stellen Enklaven für Bäume oder Gebäude dar. Das Konzept ist aber das gleiche, angewendet auf unser Beispiel Polygon ergibt sich folgende Abstraktion:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{images/routing/visibilityGraph.png}
	\caption{Visibility Graph in einer Flugzone}
	\label{fig:visibility-graph}
\end{figure}
Wie in der Grafik \ref{fig:visibility-graph} unschwer zu erkennen ist, verlaufen deutlich weniger Flugrouten entlang der Polygon Kanten. 
Dies ist ein deutlicher Fortschritt gegenüber dem ersten Konzept. Leider muss aber ehrlicherweise gesagt werden, dass die innere Ecke des L-förmigen Polygons sicher angeflogen wird, da es die vermeintlich kürzeste Route in einem nächsten Schritt darstellen wird. Aus diesem Grund wurde von einer tiefere Betrachtung des Algorithmus abgesehen.
\\
\subsubsection{Drittes Konzept: Straight Skeleton}
Durch die Recherchen für die zweite Lösung war für uns klar, dass eine ideale Lösung eine mitten betonte Flugroute empfehlen sollte. Eine einfache Lösung ohne grossen Implementationsaufwand war bereits durch die \GLS{CGAL} Bibliothek vorhanden. Diese ermöglichte es ein Straight Skeleton zu berechnen. Das Ergebnis für ein einfaches Polygon sah wie folgt aus:
\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth]{images/routing/skeleton.png}
	\caption{Skeleton in Polygon}
	\label{fig:skeleton-in-polygon}
\end{figure}
Das Skeleton stellt quasi die Gipfel Linie eines Gebirges mit der Form des Polygons dar. Die Linie ist hier neon-grün eingezeichnet, um Vollständigkeits halber anzudeuten, dass sie bereits Teil einer fertigen Lösung ist. Von diesem Graphen ausgehend, fehlen nur noch die kürzesten Linien auf die Skeletonlinie. Diese sind bekanntlich die zwei Senkrechen von den Start und den Endpunkten auf das Skeleton. 
\subsection{Graph Routing Algorithmus}
Nach der Herleitung des Graphen aus der Polygonstruktur, musste nun der passende Algorithmus gefunden werden um eine Lösung von A nach B zu finden. Es kamen 4 standard Algorithmen in Frage, wobei ein Algorithmus sich als besonders geeignet herausstellte.
\begin{itemize}
	\item{\textbf{BFS:} (\textit{Breadth-first search}) Die Breitensuche durchsucht einen Baum in der Breite. Sie bringt garantiert eine Lösung, wenn eine Lösung vorhanden ist und kann problemlos mit Zyklen im Graph umgehen. Bei der Lösung handelt es sich aber nicht um de 'optimale Lösung' (kürzester Pfad). Die Lösung liefert den Pfad mit den wenigsten Knoten. \cite{AiClass}}
	\item{\textbf{DFS:} (\textit{Depth-first search}) Die Tiefensuche fängt an einem Knoten an und arbeitet sich dann in die Tiefe. Das Problem ist, dass sie sehr anfällig auf Zyklen ist und ohne weitere Hilfsmittel (loop detection oder pruning) nicht terminieren kann. Aus diesen Gründen ist diese Lösung nicht die Beste für unser Problem. \cite{AiClass}}
	\item{\textbf{A-Star:} Der A-Star Algorithmus arbeitet mit einer Heuristik und funktioniert effizienter wie die zwei bereits genannten Algorithmen. In unserem Fall war der A-Star Algorithmus zwar eine interessante Option, da wir uns am Anfang nicht auf die 'optimale Lösung' gestürzt haben, sondern eine 'garantierte Lösung' wollten, war die Heuristik und der damit verbunden Aufwand, ein Kriterium dagegen. \cite{AiClass}}
	\item{\textbf{Dijkstra:} Der Dijkstra-Algorithmus ist ebenfalls ein klassischer Graphpropagierungsalgorithmus. Der Vorteil an ihm ist, dass er grundsätzlich ohne Heuristik auskommt und robust mit Zyklen umgehen kann. Als Metrik kann in unserem Fall einfach eine Konstante genommen werden, so optimiert er auf die kleinste Anzahl Knotentraversierungen im Lösungspfad.}
\end{itemize}
Nach genauerem Betrachten der Algorithmen haben wir uns für den Dijkstra Algorithmus entschieden. Er liefert ohne Metrik eine ähnliche Lösung wie die BFS-Suche. Der Vorteil ist, dass der Umgang mit einer Metrik bereits konzipiert ist, was ihn deutlich von der klassischen BFS-Suche unterscheidet.
In einer ersten Version haben wir auf die Längen-Metrik verzichtet, das Ziel war eine Lösung zu finden ohne zu Garantieren, dass es sich hierbei um die Beste handelt.
\subsection{Höhenhandling}
Bis an hin wurde die Höhe der einzelnen Polygone ausser acht gelassen, denn so konnten sämtlichen Polygone der drei Zonentypen zusammengefasst werden. Somit konnte mit einem Polygon, wie in der Grafik \ref{fig:skeleton-in-polygon} dargestellt, die Route berechnet werden.

Das Höhenhandling bildet nun den abschliessenden Schritt für die Routen-Berechnung und benötigt wieder Informationen der einzelnen Polygone, da die Höhe pro Zone individuell definiert werden kann.
Nachdem nun die Route innerhalb des Graphen berechnet wurden, muss für jeden Knotenpunkt die Höhe definiert werden. Dies geschieht in zwei Schritten:
\begin{itemize}
	\item{\textbf{Bestimmen der Zugehörigkeit des Knotens:} In einem ersten Schritt werden die Zonen nach Höhe absteigend sortiert. Im Anschluss werden bei einer Überlagerung von zwei Zonen die Differenzen der Polygone entfernt, somit können die höherliegenden Polygone die Tieferliegenden abdecken. Dieses Abdecken, garantiert später, dass die Punkte nur einmal zugeordnet werden und somit bei einer Überlagerung von zwei Zonen mit unterschiedlichen Höhen die Route nicht durch einen Tal vom höher- und tiefergelegenen Polygon führt.}
	\item{\textbf{Setzten der Höhe:} Es wird über alle Punkte iteriert, und die Höhe entsprechend dem Polygon indem es sich befindet gesetzt. Da die Überschneidungen nach Höhe im ersten Teil bereits vollzogen wurde, ist das Resultat eindeutig.}
\end{itemize}
\begin{figure}[h]
	\centering
	\includegraphics[width=1.0\textwidth]{images/routing/height_example.png}
	\caption{Beispiel der Höhe am Übergang zweier Polygone}
	\label{fig:polygon-border-example}
\end{figure}
Wie gemäss der Abbildung \ref{fig:polygon-border-example} ersichtlich ist, ist trotz des langen geraden Pfades zwischen den zwei Zonen ein Punkt eingefügt. Im Grunde sind es zwei Punkte, die für den Wechsel der Flughöhe verantwortlich sind.
\newpage
\subsection{Wahl der Rückroute}
Das Bilden der Rückroute erfolgt in einem sehr einfachen verfahren. Bei der aktuellen Lösung werden Start und Endpunkt mit der dazugehörigen Aktion versehen. Im Falle des Endpunktes ist es in unserem Fall der Abwurf.
\\
Nun kann dieser Pfad genommen, umgedreht und angehängt werden, wobei der letzte Punkt entfernt wird. So ist garantiert, dass die Drohne den gleichen Rückweg wie hinweg verwendet um die Mission zu erfüllen. Diese Liste wird nun an den Autopiloten übergeben.
