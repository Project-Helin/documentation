\newpage
\chapter{Umsetzung}

\section{Übersicht}

Abbildung \ref{fig:component-overview} zeigt eine grobe Übersicht der wichtigsten Komponenten und deren Verbindungen untereinander. Dieses Design orientiert sich an der Kommunikationsarchitektur, die in Kapitel \ref{sec:communication-architecture} beschrieben wurde.

\begin{figure}[H]
	\includegraphics[width=1.0\textwidth]{images/component-overview.pdf}
	\caption{Übersicht wichtigsten Schnittstellen und deren Verbindungen }
	\label{fig:component-overview}
\end{figure}
\section{Implementierung}

\subsection{Messaging Provider}
In der Architektur wurde entschieden, dass zur Kommunikation zwischen Server und Drohne ein \cite{Message-Broker} verwendet wird. Das genaue Produkt wurde allerdings noch nicht festgelegt. Folgende Broker wurden evaluiert:  \\
\begin{tabularx}{\textwidth}{|l|X|X|X|}
	\hline
	&\textbf{RabbitMQ} & \textbf{ActiveMQ} \\
	\hline
	\textbf{Vorteile} & 
	\begin{itemize}[noitemsep, topsep=1pt, leftmargin=15pt] \item{Open Source} \item{Automatischer  \mbox{Reconnect}} \end{itemize}  &
	\begin{itemize}[noitemsep, topsep=1pt, leftmargin=15pt] \item{Open Source} \end{itemize} \\
	
	\hline 
	
	
	\textbf{Nachteile} & 
	\begin{itemize}[noitemsep, topsep=1pt, leftmargin=15pt] \item{Eigene Infrastruktur benötigt} \end{itemize}  &
	\begin{itemize}[noitemsep, topsep=1pt, leftmargin=15pt] \item{Keine Android Unterstützung} \end{itemize} \\

	\hline 
\end{tabularx} \\

\subsubsection{Entscheid}
Aufgrund unserer Anforderungen wurde Entschieden, dass RabbitMQ verwendet wird. RabbitMQ unterstützt sowohl die Android Plattform (OnboardApp) als auch eine Funktionalität zum automaitschen Wiederverbinden.

\subsection{Server}

\subsubsection{Play Framework}
Für eine Anwendung in diesem Umfang ist der De-Facto-Standard SpringMVC. Da Spring aber ein schwergewichtiges Framework ist und wir eine neuere, leicht gewichtigere Alternative in der Praxis evaluieren wollten, haben wir uns für das Play Framework.

Zusätzliche Gründe die unsere Entscheidung für Play unterstützt haben:

\begin{itemize}
    \item Fortschrittlicher O/R-Mapper im Framework integriert
    \item Vorgegebene MVC-Architektur (Speziell geeignet für CRUD-Operationen)
    \item Schnelle Implementation durch Spezialisierung auf diese Anwendungsart 
    \item Alle Entwickler des Projekts sind versiert in Java
    \item RabbitMQ Anbindung möglich
    \item WebSocket Anbindung möglich
\end{itemize}

Während der Implementierung kristallisierten sich mehrere Schwächen des Frameworks heraus. 
Im Anhang \ref{ch:play_pitfalls} wird anhand einiger Beispiele erklärt, warum wir Play mit Java nur eingeschränkt weiterempfehlen können und welche Probleme damit aufgetreten sind.

\subsubsection{Kommunikation mit den Drohnen}

Wie in der Architektur beschrieben, kommunizieren die Drohnen über AMQP mit dem Messaging-Broker. Um die Möglichkeit zu haben mit einzelnen Drohnen zu kommunizieren, müssen auf dem Server zur Laufzeit alle Verbindungen zu allen Drohnen bekannt sein. Ausserdem muss en möglich sein, eingehende Nachrichten an einem zentralen Punkt abzuarbeiten. Auf Grund der bestehenden MVC-Struktur der Play-Applikation haben wir uns entschieden, auch die Nachrichten aus dem Messaging-System in Controllern zu behandeln, wie es normalerweise nur mit HTTP-Requests geschieht.\\

Die Abbildung \ref{fig:drone-communication-diagram} zeigt ein Objekt-Diagramm von Instanzen, die die Kommunikation mit den Drohnen erlauben, sobald die Applikation gestartet ist.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\paperwidth] {images/drone-communication-diagram.pdf}
	\caption{Objekt-Diagramm der Kommunkationsstruktur}
	\label{fig:drone-communication-diagram}
\end{figure}

\subsubsection{Verwendete Bibliotheken}


\begin{tabularx}{\textwidth}{|l|X|l|X|}
	\hline
	\textbf{Name} & \textbf{Verwendungszweck} & \textbf{Version} & \textbf{Lizenz} \\
	\hline \hline
	Hibernate ORM Mapper & objekt-relationales Mapping zwischen Datenbank und Java Objekten  & 5.1.0 & Apache 2.0\\
	\hline 
	RabbitMQ Client & Client Komponente zur Kommunikation mit dem Rabbit MQ Broker & 3.6.0 &  Mozilla Public License 1.1, GPL 2, Apache 2.0 \\
	\hline 
	jGraphT & Graph-Bibliothek für Java, um effizient Operationen auf dem Graph auszuführen & 0.9.2 &  LGPL, EPL \\
	\hline 
\end{tabularx} \\

Bemerkungen aus der Evaluation oben stehender Komponenten:
\begin{itemize}
	\item{\textbf{Hibernate ORM Mapper:} Hibernate ORM ist der einzige ORM Mapper, der eine Spatial-Extension anbietet. Durch Hibernate Spatial ist es möglich, PostGIS Objekte aus der Datenbank direkt zu Java Objekten zu konvertieren.}
	\item{\textbf{RabbitMQ Client:} Als Message Broker wurde auf RabbitMQ gesetzt, daher wurde konsequenterweise RabbitMQ Client als Bibliothek verwendet.}
	\item{\textbf{jGraphT:} Hibernate Spatial arbeitet mit der \Gls{Java Topology Suite} (JTS) zur Abbildung der geografischen Daten. Um aus JTS Objekten einen Graphen zu bilden, kann nur jGraphT verwendet werden.}
\end{itemize}

\subsection{Onboard-App}

\subsubsection{Entwicklungsumgebung}
Um den \Gls{Flight-Controller} mit \Gls{MAVLink} ansprechen zu können, musste eine Android/Java Library gefunden werden, die dies ermöglicht. Die Firma 3DR, der Hersteller des Pixhawk Flight-Controllers, stellt dafür eine Open-Source Android-API bereit. Die API kann im App integriert werden und erlaubt es, dem Flight-Controller direkt Befehle zu erteilen. Ausserdem kann man über diese Schnittstelle auch Telemetriedaten auslesen und Events handeln, z.B. Höhenänderungen. Damit war es möglich, die Drohne vom App und damit auch vom Server aus zu steuern.\\

Um während der Entwicklung laufend Tests durchzuführen, ohne jedes Mal mit der echten Drohne zu testen, verwendeten wir eine Software, die den Flight-Controller simuliert. Die Simulation verhält sich nahezu identisch wie ein richtiger Controller und hilft herauszufinden, ob die gesendeten Befehle die erwartete Wirkung zeigten. \\

Die verschiedenen Möglichkeiten, dass System zu testen sind im Github Repository dokumentiert. In der Abbildung \ref{fig:test-setup-onboard} wird ein Setup gezeigt, bei dem die Onboard-App im Android Emulator läuft (rechts unten). Gleichzeitig zeigt die Bodenstationssoftware die Echtzeit-Daten des simulierten Fluges an.

\begin{figure}[H]
	\includegraphics[width=1.0\textwidth]{images/test-setup-onboard.png}
	\caption{APM Planner 2.0 als Bodenstation und Android Emulator mit Onboard App}
	\label{fig:test-setup-onboard}
\end{figure}

\subsubsection{Verwendete Bibliotheken}
\begin{tabularx}{\textwidth}{|X|X|c|X|}
	\hline
	\textbf{Name} & \textbf{Verwendungszweck} & \textbf{Version} & \textbf{Lizenz} \\
	\hline \hline
	DroneKit-Android Client & Android API für MAV-Link Protokoll zum ansteuern der Drohne & 1.5.1 & Apache 2.0\\
	\hline 
	AMQP Messaging Library & Messaging für Android & 3.6.0 &  Mozilla Public License 1.1, GPL 2,  Apache 2.0 \\
	\hline 
	Lyra  & High availability Messaging & 0.4.3 &  Apache 2.0 \\
	\hline 
	Dagger  & Dependency Injection Framwork für Android & 2.0.1 &  Apache 2.0 \\
	\hline 
\end{tabularx} \\

Bemerkungen aus der Evaluation oben stehender Komponenten:
\begin{itemize}
	\item{\textbf{DroneKit-Android Client:} Es existiert keine gleichwertige Alternative die das \Gls{MAVLink} Protokoll in diesem Umfang abdeckt.}
	\item{\textbf{AMQP Messaging Library:} Ist Voraussetzung für die Lyra Bibliothek um dieser das \Gls{AMQP} Protokoll zur Verfügung zu stellen.}
	\item{\textbf{Lyra:} Die Bibliothek wird vom Hersteller der Message-Oriented-Middleware empfohlen. \cite[]{lyra-page} }
	\item{\textbf{Dagger:} Wird von Google entwickelt und unterstützt Dependency Injection zur Kompilierzeit.}
\end{itemize}

\subsubsection{Kommunikation zum Server}

Gemäss den nicht-funktionalen Anforderungen soll ein Verbindungsabbruch zum Server keinen Einfluss auf die Ausführung der Lieferung haben. Deshalb wird die Flugroute vor dem Start auf den \Gls{Flight-Controller} übertragen, somit kann die Mission auch ohne Online-Verbindung erfolgreich abgeschlossen werden. \\

Sollte die Verbindung zwischen Server und Onboard-App unterbrochen sein, sollte verhindert werden, dass Nachrichten verloren gehen. Bei unterbrochener Verbindung wird dies wie folgt erreicht:
\begin{itemize}
	\item{\textbf{Nachricht vom Server zum Onboard-App} \\
		Dieses Szenario wird durch RabbitMQ abgefangen. Der Messaging-Broker persistiert die Nachrichten solange bis die Onboard-App wieder verfügbar ist. Es besteht somit kein zusätzlicher Handlungsbedarf.
	}
	\item{\textbf{Nachricht vom Onboard-App an den Server} \\
		Hier steht der Broker nicht zur Verfügung und die Speicherung der Nachrichten musste implementiert werden. Dazu verwenden wir eine Queue in der alle Nachrichten gespeichert werden und erst entfernt werden, wenn sie verschickt wurden.
	}
\end{itemize}
Mit diesen Massnahmen haben wir eine gute Balance zwischen Zuverlässigkeit und Implementationsaufwand erreicht.
}


\subsubsection{Verbindungswiederherstellung}
Gemäss den nicht-funktionalen Anforderungen, muss sichergestellt werden, dass nach einem Unterbruch der Internetverbindung eine Verbindungswiederherstellung stattfindet. Sobald die Verbindung mit dem Internet wieder besteht, soll nach 30 Sekunden wieder eine Verbindung zum Message-Broker bestehen. \\

Bei der Konfiguration der Verbindungswiederherstellung bestand die Wahl zwischen fixen oder inkrementellen Zeitabständen, nach denen eine Wiederherstellung versucht wird. Um das exakte Verhalten zu evaluieren, wurden Versuche gemacht, bei denen die Verbindung für 3 Sekunden unterbrochen wurde (siehe Tabelle \ref{tbl:backoff}).\\

\begin{table}
	
	\centering
	\begin{tabular}{|r|r|r|}
		\hline
		\textbf{Versuch} & \textbf{Mit inkrementellem Intervall [s] } & \textbf{Mit fixem Intervall [s])} \\
		\hline
		1 & 17 & 7 \\
		2 &	7 & 7 \\
		3 & 9 & 7 \\
 		4 & 11 & 7 \\
		5 & 10 & 7 \\
		\hline
	\end{tabular}
	\caption{Benötigte Zeit für Verbindungswiederherstellung}
	\label{tbl:backoff}
\end{table}

Da beide Varianten die nicht-funktionalen Anforderungen erfüllen, haben wir uns nach den Versuchen für ein inkrementelles Intervall entschieden, um das Smartphone nicht unnötig zu belasten.

\subsection{Customer App}
Gemäss Aufgabenstellung sollte ein Prototyp für eine App, mit welchem Bestellungen am System abgegeben können, entwickelt werden.

Anders als die Onboard-App, welche native mit Java entwickelt wurde und nur auf Android läuft, entschieden wir uns beim Bestell-App für eine Cross-Plattform Lösung, welche Android und iOS unterstützt. \\

Auch wenn gemäss der Aufgabenstellung keine iOS App gefordert war, stellte sich doch die Frage ob man die iPhone-Kunden ausschliessen soll und spätere Entwickler zwingt, einen grossen Teil des Codes in einer nativen iOS App duplizieren zu müssen. Mit einem Marktanteil von 42.2\% (Zahlen 2015) \cite{ios-user} von iOS Benutzern in der Schweiz, ist anzunehmen, dass zu einem späteren Zeitpunkt eine iPhone App implementiert werden muss.\\

Deshalb wurde auf Xamarin Forms gesetzt, welches ermöglicht, die ganzen Service-Klassen und einen Teil der Benutzeroberfläche für die verschiedenen Plattformen nur einmal zu implementieren.

Die App wurde in einer minimalen Ausbaustufe erstellt, erfüllt aber bereits alle nötigen funktionalen Anforderungen. In Abbildung \ref{fig:customer-app-flow} wird gezeigt, wie ein Benutzer durch die App navigieren kann. 

Besonders wichtig ist die Anzeige des berechneten Abwurfpunktes vor der Bezahlung der Ware, sowie die Anzeige der Drohnenposition während des Anflugs.  

\begin{landscape}
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.8\paperheight] {images/customer-app-pages.png}
		\caption{Übersicht der Customer App mit allen Verknüpfungen zwischen den Screens}
		\label{fig:customer-app-flow}
	\end{figure}
\end{landscape}

\subsubsection{Verwendete Bibliotheken}
\begin{tabularx}{\textwidth}{|X|X|c|X|}
	\hline
	\textbf{Name} & \textbf{Verwendungszweck} & \textbf{Version} & \textbf{Lizenz} \\
	\hline \hline
	Paypal Forms & Paypal integration für Xamarin.Forms & 2.0.4 & MIT \\
	\hline 
	Xamarin Forms & Plattform übergreifende Komponente für Xamarin & 2.2.0.45 & \url{https://www.xamarin.com/license} \\
	\hline 
	Websocket.PCL & Plattformübergreifende WebSocket Anbindung & 1.1.9 & MIT \\
	\hline 
	Newton.Json & Json zu Object mapper & 8.0.3 & MIT \\
	\hline 
\end{tabularx}\\

Bemerkungen aus der Evaluation oben stehender Komponenten:
\begin{itemize}
	\item{\textbf{Paypal Forms:} Einziges Paypal Plugin für Xamarin.Forms}
	\item{\textbf{Xamarin.Forms:} Ermöglicht Crossplattform UI sehr einfach zu entwickeln.}
	\item{\textbf{Websocket.PCL:} Einzige gut gewartete Implementation der WebSockets in Xamarin}
	\item{\textbf{Newton.Json:} Die Bibliothek weisst die höchste Anzahl Downloads auf.}
\end{itemize}

\subsection{Sicherheit}
Es ist essentiell, dass die Sicherheit bei der Kommunkation zwischen Server und Drohne gewährleistet ist, da sonst die Kontrolle über eine Drohne übernommen werden könnte (siehe NFR \ref{sec:message-security}). Um diese Sicherheit zu gewährleisten wurde ein Prozess eingeführt, der es ermöglicht die Zugangsdaten für den RabbitMQ-Broker und die Queue-Namen geheim zu halten: \\

Die Onboard-App registriert sich über einen HTTPS Request beim Server. Bei erfolgreicher Registrierung der Drohne, wird ein Token sowie der Benutzer und das Kennwort für die Verbindung zu RabbitMQ an die Onboard-App geschickt. Mit diesen Informationen kann sich die App mit dem Messaging Broker über eine verschlüsselte Leitung verbinden.\\

Für die darauf folgende Kommunikation mit dem Broker, werden mit Hilfe des Tokens zwei Queues erzeugt: 
\begin{itemize}
	\item \{token\}-Drone-To-Server
	\item  \{token\}-Server-To-Drone
\end{itemize}

Über diese Queues können jetzt Nachrichten ausgetauscht werden. \\

Ein Angreifer müsste mit dieser Methode den Token herausfinden und auch die Zugangsdaten für den Broker kennen, um mit einer Drohne zu kommunizieren. Falls jemand es aber doch schaffen würde, die Benutzerdaten auszulesen, gibt es trotzdem noch $2^{122}$ mögliche Tokens, die durchprobiert werden müssten. \\

\section{Projektgrösse}

Folgende Statistiken wurden am Ende der Arbeit erstellt um einen Eindruck der Grösse des Projekts zu erhalten.\\

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth] {images/code-metrics.png}
	\caption{Code Metriken nach Abschluss der Arbeit}
	\label{fig:code-metrics}
\end{figure}

In Abbildung \ref{fig:code-metrics} sind vor allem der geringe Anteil von Methoden mit hoher essentieller Komplexität\cite[S. 79]{MCCABE} hervorzuheben. Alle Methoden mit hoher Komplexität wurden vom Team geprüft, konnten aber nicht mehr verbessert werden. Hauptsächlich sind dies 'equals' Methoden von grösseren \Gls{DTO}s oder es handelt sich um MessageConverter, die einfach alle verschiedenen Messagetypen verschieden behandeln müssen. Das folgende Beispiel zeigt die Methode mit der höchsten zyklomatischen Komplexität der Server-Applikation (Essentielle Komplexität = 10, Zyklomatische Komplexität = 10). \\


\begin{lstlisting}
private Message parseMessageWithoutCare(String messageAsJson) {
	...
	switch (payloadType) {
		case ConfirmCargoLoaded:
			return gson.fromJson(messageAsJson, ConfirmCargoLoaded.class);
		case NotifyCargoDrop:
			return gson.fromJson(messageAsJson, NotifyCargoDrop.class);
		case DroneInfo:
			return gson.fromJson(messageAsJson, DroneInfoMessage.class);
		case DroneDto:
			return gson.fromJson(messageAsJson, DroneDtoMessage.class);
		case AssignMission:
			return gson.fromJson(messageAsJson, AssignMissionMessage.class);
		case FinalAssignMission:
			return gson.fromJson(messageAsJson, FinalAssignMissionMessage.class);
		case ConfirmMission:
			return gson.fromJson(messageAsJson, ConfirmMissionMessage.class);
		case FinishedMission:
			return gson.fromJson(messageAsJson, FinishedMissionMessage.class);
		case DroneActiveState:
			return gson.fromJson(messageAsJson, DroneActiveStateMessage.class);
	}
}

\end{lstlisting}

Da diese Methode gut strukturiert ist und auch gut verstanden werden kann, gibt es keinen Grund, diese auf Grund der Metrik anzupassen.

\section{Qualitätssicherung}
\label{quality-assurance}

\subsection{Prozesse}

Zur Qualitätssicherung wurde im Projektmanagement-Tool neben Todo, In Progress und Done ein neuer Quality-Assurance-Status für die Issues eingeführt. Alle Issues in diesem Status mussten von einem anderen Teammitglied überprüft werden, bevor sie auf Done geschoben werden konnten. \\

Die Überprüfung eines Issues beinhaltet folgende Aufgaben:

\begin{itemize}
	\item{Akzeptanzkriterien aus der User-Story manuell prüfen}
	\item{Code-Review durchführen (Intensität je nach Grösse und Komplexität des geschriebenen Codes)}
	\item{Code auf Vertösse gegen Style-Guide prüfen}
	\item{Prüfen der Tests vorhanden sind}
\end{itemize}

Damit konnten viele Fehler früh entdeckt werden und die Code-Qualität konnte über die ganze Projektdauer konstant gehalten werden.

\subsection{Continous Integration}

Als Build-Server haben wir TeamCity verwendet. Dort sind alle Projekte (ausser Customer-App) jeweils mit einem Build für den develop- und master-branch eingerichtet. Alle Builds führten die Tests aus und produzierten ein entsprechendes Artifact für das Deployment. Das Deployment für den Server wurde ebenfalls automatisiert.

\subsection{Testing}

Je nach Plattform wurden andere Formen von Tests durchgeführt:

\subsubsection{Server}

Auf dem Server wurden vor allem \Gls{E2E}- und \Gls{Integration}-Tests verwendet um die Funktionalität zu prüfen. Wir haben uns bei den meisten Kompoonenten bewusst gegen \Gls{Unit-Tests} entschieden, da auf dem Server nur wenig Logik zu finden ist, die nicht von der Datenbank oder der RabbitMQ-Connection abhängt. Unit-Tests hätten deswegen nur einen ganz kleinen Teil der Anwendungen abdecken können und wären in den meisten Fällen sehr aufwendig gewesen. Bei der Routenberechnung hingegen konnte sehr gut mit Unit-Tests gearbeitet werden.\\

Wir haben darauf geachtet, dass immer nur die minimale Integrationsstufe gewählt wurde. Für die Simulation eines Benutzers (E2E) wurde Selenium verwendet, das wiederum einen Firefox Browser verwendet. Für die Api- und Messaging-Controller wurden Integrationtests verwendet, welche keinen Browser benötigen.\\

Es wurde eine \textbf{durchschnittliche Testabdeckung von 72\%} über das ganze Projekt erreicht. In wichtigen Packages liegt diese aber meist über 85\%.

\subsubsection{Onboard-App}

Beim Onboard App wurden nur Unit-Tests ausgeführt. Der Aufbau von E2E Tests ist denkbar, hätte den Rahmen dieser Arbeit aber gesprengt. Deshalb wurden hauptsächlich die Message-Handler und die Daten-Mapper getestet. Diese haben eine \textbf{Testabdeckung von 86\%}.

\subsubsection{Customer-App}

Bei der Customer App wurden keine Tests eingerichtet, da es sich um einen Prototypen handelt.


